<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåç Simulaci√≥n de Deflecci√≥n de Meteoritos - F√≠sica Realista</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000011;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000011 0%, #001122 100%);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            font-size: 18px;
        }
        
        #loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(76, 175, 80, 0.3);
            border-left: 4px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 12px;
            max-width: 380px;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            display: none;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .control-group {
            margin: 15px 0;
            border-bottom: 1px solid rgba(76, 175, 80, 0.3);
            padding-bottom: 10px;
        }
        
        .control-group:last-child {
            border-bottom: none;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 8px 0;
            height: 6px;
            border-radius: 5px;
            background: #333;
            outline: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }
        
        input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #333;
            border-radius: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            font-size: 14px;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 5px 3px;
            font-size: 13px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            width: calc(50% - 6px);
        }
        
        button:hover {
            background: linear-gradient(45deg, #45a049, #4CAF50);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        
        button.danger:hover {
            background: linear-gradient(45deg, #d32f2f, #f44336);
        }
        
        button.warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
        }
        
        button.warning:hover {
            background: linear-gradient(45deg, #f57c00, #ff9800);
        }
        
        h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
            text-align: center;
            font-size: 18px;
        }
        
        h4 {
            margin: 15px 0 10px 0;
            color: #81C784;
            font-size: 16px;
        }
        
        .info-display {
            background: linear-gradient(45deg, rgba(76, 175, 80, 0.2), rgba(69, 160, 73, 0.2));
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-size: 14px;
            border: 1px solid #4CAF50;
        }
        
        .time-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin: 10px 0;
        }
        
        .time-controls button {
            width: 100%;
            margin: 0;
            padding: 8px;
            font-size: 12px;
        }
        
        #debug-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #333;
            max-width: 300px;
            display: none;
        }
        
        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 10px;
            border: 2px solid #4CAF50;
            font-size: 16px;
            z-index: 1000;
            display: none;
            text-align: center;
        }
        
        .trajectory-legend {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
        }
        
        .trajectory-legend div {
            margin: 5px 0;
            display: flex;
            align-items: center;
        }
        
        .trajectory-legend .color-box {
            width: 20px;
            height: 3px;
            margin-right: 10px;
            border-radius: 2px;
        }
        
        .status-critical {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid #f44336;
            color: #ff5555;
        }
        
        .status-warning {
            background: rgba(255, 152, 0, 0.2);
            border: 1px solid #ff9800;
            color: #ffb74d;
        }
        
        .status-safe {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid #4CAF50;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div id="loading-spinner"></div>
        <h2>üåç Cargando Simulaci√≥n de Deflecci√≥n</h2>
        <p id="loading-status">Inicializando Cannon.js y Three.js...</p>
    </div>
    
    <div id="canvas-container">
        <!-- El canvas se insertar√° aqu√≠ -->
    </div>
    
    <div id="ui">
        <h3>üõ°Ô∏è Control de Deflecci√≥n de Meteoritos</h3>
        
        <!-- Estado del Sistema -->
        <div class="info-display status-safe" id="system-status">
            <strong>üõ∞Ô∏è Sistema: Operacional</strong><br>
            <span id="meteorite-status">Sin amenazas detectadas</span>
        </div>
        
        <!-- Control de Tiempo -->
        <div class="control-group">
            <h4>‚è∞ Control Temporal</h4>
            <div class="info-display">
                <strong>Tiempo: <span id="simulation-time">0.00</span>s</strong><br>
                <strong>Velocidad: <span id="time-scale-display">1.0x</span></strong>
            </div>
            
            <label>üöÄ Velocidad de Simulaci√≥n:</label>
            <input type="range" id="time-scale" min="0" max="5" step="0.1" value="1">
            
            <div class="time-controls">
                <button id="pause-btn">‚è∏Ô∏è Pausa</button>
                <button id="step-btn">üìù Step</button>
                <button id="reset-time-btn">üîÑ Reset</button>
            </div>
        </div>
        
        <!-- Par√°metros del Meteorito -->
        <div class="control-group">
            <h4>‚òÑÔ∏è Par√°metros del Meteorito</h4>
            
            <label>üìè Tama√±o (metros):</label>
            <input type="number" id="meteorite-size" value="50" min="1" max="1000" step="1">
            <span id="size-display">50m</span>
            
            <label>‚öñÔ∏è Densidad (kg/m¬≥):</label>
            <input type="range" id="meteorite-density" min="1000" max="8000" step="100" value="2700">
            <span id="density-display">Roca (2700)</span>
            
            <label>üèÉ Velocidad (km/s):</label>
            <input type="number" id="meteorite-velocity" value="20" min="1" max="70" step="1">
            <span id="velocity-display">20 km/s</span>
            
            <div class="info-display">
                <strong>üíÄ Masa calculada: <span id="mass-display">--</span></strong><br>
                <strong>‚ö° Energ√≠a cin√©tica: <span id="energy-display">--</span></strong>
            </div>
        </div>
        
        <!-- Control de Meteoritos -->
        <div class="control-group">
            <h4>üöÄ Generar Amenaza</h4>
            <button id="create-meteorite">‚òÑÔ∏è Crear Meteorito</button>
            <button id="create-apophis" class="warning">üî• Simular Apophis</button>
            <button id="clear-meteorites" class="danger">üí• Limpiar Todo</button>
        </div>
        
        <!-- Estrategias de Deflecci√≥n -->
        <div class="control-group">
            <h4>üõ°Ô∏è Estrategias de Deflecci√≥n</h4>
            
            <button id="kinetic-impact">üí• Impacto Cin√©tico</button>
            <button id="nuclear-pulse" class="danger">‚ò¢Ô∏è Pulso Nuclear</button>
            <button id="gravity-tractor" class="warning">üõ∞Ô∏è Tractor Gravitacional</button>
            <button id="ion-beam">‚ö° Haz de Iones</button>
        </div>
        
        <!-- Visualizaci√≥n -->
        <div class="control-group">
            <h4>üëÅÔ∏è Visualizaci√≥n</h4>
            
            <button id="toggle-trajectories">üìà Trayectorias</button>
            <button id="toggle-prediction">üîÆ Predicci√≥n</button>
            <button id="toggle-grid">üìê Cuadr√≠cula</button>
            <button id="toggle-atmosphere">üå´Ô∏è Atm√≥sfera</button>
            
            <div class="trajectory-legend">
                <div><div class="color-box" style="background: #00ff00;"></div>Trayectoria Real</div>
                <div><div class="color-box" style="background: #ff0000;"></div>Predicci√≥n</div>
                <div><div class="color-box" style="background: #ffff00;"></div>Post-Deflecci√≥n</div>
            </div>
        </div>
        
        <!-- Informaci√≥n de Impacto -->
        <div class="control-group">
            <h4>üéØ An√°lisis de Impacto</h4>
            <div class="info-display" id="impact-analysis">
                <strong>üìç Distancia a la Tierra:</strong> <span id="distance-display">--</span><br>
                <strong>‚è±Ô∏è Tiempo hasta impacto:</strong> <span id="impact-time-display">--</span><br>
                <strong>üìä Probabilidad de impacto:</strong> <span id="impact-probability">--</span>
            </div>
        </div>
    </div>
    
    <div id="debug-info">
        <div><strong>üîç Debug Info:</strong></div>
        <div id="fps-counter"></div>
        <div id="physics-info"></div>
        <div id="meteorite-count"></div>
    </div>
    
    <div id="notification"></div>

    <!-- Cannon.js Physics Engine -->
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.20.0/build/cannon.min.js"></script>
    
    <!-- Three.js desde m√∫ltiples CDNs con fallback -->
    <script>
        // ==========================================
        // üöÄ SIMULACI√ìN DE DEFLECCI√ìN DE METEORITOS
        // ==========================================
        
        console.log('üöÄ Iniciando simulaci√≥n de deflecci√≥n de meteoritos...');
        
        // Variables globales
        let scene, camera, renderer, world;
        let earth, earthBody;
        let meteorites = [];
        let trajectoryTrackers = [];
        let timeController;
        let animationId;
        let lastTime = 0;
        
        // Configuraci√≥n f√≠sica
        const EARTH_RADIUS = 6.371; // millones de metros (escala)
        const EARTH_MASS = 5.972e24;
        const G = 6.674e-11;
        
        // Configuraci√≥n de CDNs
        const CDN_CONFIGS = [
            {
                name: 'jsDelivr',
                three: 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js'
            },
            {
                name: 'unpkg',
                three: 'https://unpkg.com/three@0.158.0/build/three.min.js'
            }
        ];
        
        // ==========================================
        // üï∞Ô∏è CONTROLADOR DE TIEMPO
        // ==========================================
        
        class TimeController {
            constructor() {
                this.timeScale = 1.0;
                this.isPaused = false;
                this.simulationTime = 0;
                this.maxDeltaTime = 1/60;
            }
            
            setTimeScale(scale) {
                this.timeScale = Math.max(0, Math.min(scale, 10));
                document.getElementById('time-scale-display').textContent = `${this.timeScale.toFixed(1)}x`;
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('pause-btn');
                btn.textContent = this.isPaused ? '‚ñ∂Ô∏è Play' : '‚è∏Ô∏è Pausa';
                return this.isPaused;
            }
            
            step() {
                if (this.isPaused) {
                    return this.maxDeltaTime;
                }
                return 0;
            }
            
            reset() {
                this.simulationTime = 0;
                document.getElementById('simulation-time').textContent = '0.00';
            }
            
            update(rawDeltaTime) {
                let deltaTime = 0;
                
                if (!this.isPaused) {
                    deltaTime = Math.min(rawDeltaTime * this.timeScale, this.maxDeltaTime);
                    this.simulationTime += deltaTime;
                }
                
                // Actualizar display
                document.getElementById('simulation-time').textContent = this.simulationTime.toFixed(2);
                
                return deltaTime;
            }
        }
        
        // ==========================================
        // üìà RASTREADOR DE TRAYECTORIAS
        // ==========================================
        
        class TrajectoryTracker {
            constructor(meteorite, maxPoints = 500) {
                this.meteorite = meteorite;
                this.positions = [];
                this.maxPoints = maxPoints;
                this.visible = true;
                
                this.createTrajectoryLine();
                this.createPredictionLine();
            }
            
            createTrajectoryLine() {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true,
                    opacity: 0.8
                });
                
                this.line = new THREE.Line(geometry, material);
                scene.add(this.line);
            }
            
            createPredictionLine() {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xff0000, 
                    transparent: true,
                    opacity: 0.6
                });
                
                this.predictionLine = new THREE.Line(geometry, material);
                scene.add(this.predictionLine);
            }
            
            update() {
                if (!this.visible) return;
                
                const currentPos = this.meteorite.body.position.clone();
                this.positions.push(currentPos);
                
                if (this.positions.length > this.maxPoints) {
                    this.positions.shift();
                }
                
                const points = this.positions.map(pos => new THREE.Vector3(pos.x, pos.y, pos.z));
                this.line.geometry.setFromPoints(points);
            }
            
            predictTrajectory(steps = 200, timeStep = 0.1) {
                if (!this.visible) return;
                
                const predictions = [];
                let pos = this.meteorite.body.position.clone();
                let vel = this.meteorite.body.velocity.clone();
                
                for (let i = 0; i < steps; i++) {
                    // Gravedad terrestre
                    const earthPos = new CANNON.Vec3(0, 0, 0);
                    const direction = earthPos.vsub(pos);
                    const distance = direction.length();
                    
                    if (distance > EARTH_RADIUS) {
                        const force = (G * EARTH_MASS * 1000) / (distance * distance * 1e12);
                        const acceleration = direction.unit().scale(force);
                        vel = vel.vadd(acceleration.scale(timeStep));
                    }
                    
                    pos = pos.vadd(vel.scale(timeStep));
                    predictions.push(pos.clone());
                    
                    if (distance <= EARTH_RADIUS + 0.5) break;
                }
                
                const points = predictions.map(pos => new THREE.Vector3(pos.x, pos.y, pos.z));
                this.predictionLine.geometry.setFromPoints(points);
            }
            
            setVisibility(visible) {
                this.visible = visible;
                this.line.visible = visible;
                this.predictionLine.visible = visible;
            }
            
            dispose() {
                scene.remove(this.line);
                scene.remove(this.predictionLine);
            }
        }
        
        // ==========================================
        // ‚òÑÔ∏è CLASE METEORITO
        // ==========================================
        
        class Meteorite {
            constructor(params = {}) {
                const {
                    size = 50,
                    density = 2700,
                    velocity = [20000, 0, 0],
                    position = [100, 0, 0]
                } = params;
                
                this.size = size;
                this.density = density;
                this.calculateMass();
                
                this.createPhysicsBody(position, velocity);
                this.createVisualMesh();
                this.createTrajectoryTracker();
                
                meteorites.push(this);
                this.updateUI();
            }
            
            calculateMass() {
                const volume = (4/3) * Math.PI * Math.pow(this.size/2, 3);
                this.mass = volume * this.density;
                this.kineticEnergy = 0.5 * this.mass * Math.pow(this.getSpeed(), 2);
            }
            
            createPhysicsBody(position, velocity) {
                const scaledSize = this.size / 1000; // Escala para visualizaci√≥n
                
                this.body = new CANNON.Body({ 
                    mass: this.mass,
                    shape: new CANNON.Sphere(scaledSize),
                    material: new CANNON.Material({ friction: 0.3, restitution: 0.3 })
                });
                
                this.body.position.set(...position);
                this.body.velocity.set(...velocity.map(v => v / 1000)); // Escalar velocidad
                
                world.add(this.body);
            }
            
            createVisualMesh() {
                const scaledSize = this.size / 1000;
                const geometry = new THREE.SphereGeometry(scaledSize, 16, 16);
                
                // Color basado en composici√≥n
                let color = 0x8B4513; // Roca marr√≥n por defecto
                if (this.density > 5000) color = 0x666666; // Met√°lico
                if (this.density < 2000) color = 0x87CEEB; // Hielo
                
                const material = new THREE.MeshPhongMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.9
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                scene.add(this.mesh);
            }
            
            createTrajectoryTracker() {
                this.trajectoryTracker = new TrajectoryTracker(this);
                trajectoryTrackers.push(this.trajectoryTracker);
            }
            
            update() {
                // Sincronizar visual con f√≠sica
                this.mesh.position.copy(this.body.position);
                this.mesh.quaternion.copy(this.body.quaternion);
                
                // Actualizar trayectoria
                this.trajectoryTracker.update();
                
                // An√°lisis de impacto
                this.analyzeImpact();
            }
            
            analyzeImpact() {
                const distance = this.body.position.length();
                const velocity = this.body.velocity.length() * 1000; // Convertir a m/s
                
                document.getElementById('distance-display').textContent = 
                    `${(distance * 1000 - EARTH_RADIUS * 1000).toFixed(0)} km`;
                
                if (distance <= EARTH_RADIUS + 0.5) {
                    this.impact();
                } else {
                    // Calcular tiempo hasta impacto (aproximado)
                    const timeToImpact = (distance - EARTH_RADIUS) / (velocity / 1000);
                    document.getElementById('impact-time-display').textContent = 
                        `${timeToImpact.toFixed(1)}s`;
                }
            }
            
            impact() {
                const velocity = this.body.velocity.length() * 1000;
                const energy = 0.5 * this.mass * velocity * velocity;
                const tntEquivalent = energy / 4.184e9; // Convertir a toneladas de TNT
                
                showNotification(`üí• ¬°IMPACTO! Energ√≠a: ${tntEquivalent.toFixed(0)} ton TNT`, 5000);
                
                // Crear cr√°ter en la Tierra
                this.createImpactCrater();
                
                // Remover meteorito
                this.destroy();
            }
            
            createImpactCrater() {
                const impactPos = this.body.position.clone().normalize().scale(EARTH_RADIUS + 0.01);
                
                const craterSize = Math.min(this.size / 5000, 0.5); // Escala del cr√°ter
                const craterGeometry = new THREE.RingGeometry(craterSize * 0.3, craterSize, 8, 1);
                const craterMaterial = new THREE.MeshPhongMaterial({
                    color: 0x5D4037,
                    transparent: true,
                    opacity: 0.8
                });
                
                const crater = new THREE.Mesh(craterGeometry, craterMaterial);
                crater.position.copy(impactPos);
                crater.lookAt(0, 0, 0);
                
                earth.add(crater);
            }
            
            getSpeed() {
                return this.body.velocity.length() * 1000; // Convertir a m/s
            }
            
            updateUI() {
                document.getElementById('mass-display').textContent = 
                    `${(this.mass / 1e6).toFixed(2)} Mt`;
                document.getElementById('energy-display').textContent = 
                    `${(this.kineticEnergy / 4.184e15).toFixed(2)} Mt TNT`;
            }
            
            destroy() {
                world.remove(this.body);
                scene.remove(this.mesh);
                this.trajectoryTracker.dispose();
                
                const index = meteorites.indexOf(this);
                if (index > -1) meteorites.splice(index, 1);
                
                const trackerIndex = trajectoryTrackers.indexOf(this.trajectoryTracker);
                if (trackerIndex > -1) trajectoryTrackers.splice(trackerIndex, 1);
            }
        }
        
        // ==========================================
        // üõ°Ô∏è SISTEMA DE DEFLECCI√ìN
        // ==========================================
        
        class DeflectionSystem {
            static kineticImpact(meteorite) {
                if (!meteorite) return;
                
                const impactorMass = 500; // kg (como DART)
                const relativeVelocity = 50000; // m/s
                
                const impulse = new CANNON.Vec3(-relativeVelocity/1000, 0, 0);
                impulse.scale(impactorMass, impulse);
                
                meteorite.body.applyImpulse(impulse, meteorite.body.position);
                
                showNotification('üí• Impacto cin√©tico ejecutado!', 3000);
                console.log('üéØ Impacto cin√©tico aplicado:', impulse);
            }
            
            static nuclearPulse(meteorite) {
                if (!meteorite) return;
                
                const yieldTNT = 1e6; // 1 megat√≥n
                const distance = 1; // km de distancia
                
                const direction = meteorite.body.position.clone().normalize();
                const impulse = direction.scale(yieldTNT * 100 / 1000);
                
                meteorite.body.applyImpulse(impulse, meteorite.body.position);
                
                showNotification('‚ò¢Ô∏è Pulso nuclear detonado!', 3000);
                console.log('üí£ Pulso nuclear aplicado:', impulse);
            }
            
            static gravityTractor(meteorite) {
                if (!meteorite) return;
                
                // Implementar como fuerza constante
                meteorite.gravityTractorActive = !meteorite.gravityTractorActive;
                
                if (meteorite.gravityTractorActive) {
                    showNotification('üõ∞Ô∏è Tractor gravitacional activado!', 3000);
                } else {
                    showNotification('üõ∞Ô∏è Tractor gravitacional desactivado!', 2000);
                }
            }
            
            static ionBeam(meteorite) {
                if (!meteorite) return;
                
                const beamForce = new CANNON.Vec3(0, 1000/1000, 0); // Fuerza perpendicular
                meteorite.body.applyImpulse(beamForce, meteorite.body.position);
                
                showNotification('‚ö° Haz de iones activado!', 3000);
                console.log('‚ö° Haz de iones aplicado:', beamForce);
            }
        }
        
        // ==========================================
        // FUNCIONES DE CARGA Y INICIALIZACI√ìN
        // ==========================================
        
        function updateLoadingStatus(message) {
            const statusElement = document.getElementById('loading-status');
            if (statusElement) {
                statusElement.textContent = message;
            }
            console.log('üîÑ', message);
        }
        
        function loadScript(url, timeout = 15000) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = url;
                script.async = true;
                
                const timer = setTimeout(() => {
                    script.remove();
                    reject(new Error(`Timeout: ${url}`));
                }, timeout);
                
                script.onload = () => {
                    clearTimeout(timer);
                    resolve();
                };
                
                script.onerror = () => {
                    clearTimeout(timer);
                    script.remove();
                    reject(new Error(`Error loading: ${url}`));
                };
                
                document.head.appendChild(script);
            });
        }
        
        async function loadThreeJS() {
            updateLoadingStatus('üîç Cargando Three.js...');
            
            for (let config of CDN_CONFIGS) {
                try {
                    await loadScript(config.three);
                    
                    if (typeof THREE === 'undefined') {
                        throw new Error('THREE no definido');
                    }
                    
                    console.log(`‚úÖ Three.js cargado desde ${config.name}`);
                    return true;
                    
                } catch (error) {
                    console.warn(`‚ùå Fall√≥ ${config.name}:`, error.message);
                }
            }
            
            throw new Error('Todos los CDNs de Three.js fallaron');
        }
        
        function initPhysics() {
            updateLoadingStatus('‚öñÔ∏è Configurando f√≠sica...');
            
            world = new CANNON.World();
            world.gravity.set(0, 0, 0); // Sin gravedad global, la calculamos manualmente
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            
            // Crear cuerpo de la Tierra
            earthBody = new CANNON.Body({ 
                mass: 0, // Est√°tico
                shape: new CANNON.Sphere(EARTH_RADIUS),
                position: new CANNON.Vec3(0, 0, 0)
            });
            world.add(earthBody);
            
            console.log('‚öñÔ∏è Mundo f√≠sico inicializado');
        }
        
        function initThreeJS() {
            updateLoadingStatus('üéÆ Configurando Three.js...');
            
            // Crear escena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // Configurar c√°mara
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(20, 10, 20);
            camera.lookAt(0, 0, 0);
            
            // Configurar renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            const container = document.getElementById('canvas-container');
            container.appendChild(renderer.domElement);
            
            createEarth();
            createLighting();
            createStarField();
            setupControls();
            
            console.log('üéÆ Three.js inicializado');
        }
        
        function createEarth() {
            // Crear textura procedural mejorada
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Oc√©anos
            ctx.fillStyle = '#1565C0';
            ctx.fillRect(0, 0, 1024, 512);
            
            // Continentes m√°s detallados
            ctx.fillStyle = '#2E7D32';
            
            // Am√©rica
            ctx.beginPath();
            ctx.ellipse(200, 200, 60, 120, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Europa/√Åfrica
            ctx.beginPath();
            ctx.ellipse(500, 180, 80, 100, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Asia
            ctx.beginPath();
            ctx.ellipse(700, 150, 100, 80, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Ocean√≠a
            ctx.beginPath();
            ctx.ellipse(800, 350, 40, 30, 0, 0, Math.PI * 2);
            ctx.fill();
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            
            const geometry = new THREE.SphereGeometry(EARTH_RADIUS, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                map: texture,
                shininess: 10
            });
            
            earth = new THREE.Mesh(geometry, material);
            earth.castShadow = true;
            earth.receiveShadow = true;
            scene.add(earth);
        }
        
        function createLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            
            scene.add(directionalLight);
        }
        
        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 2000;
            
            const positions = new Float32Array(starCount * 3);
            
            for (let i = 0; i < starCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 1000;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const starMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 3,
                sizeAttenuation: false
            });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function setupControls() {
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            document.addEventListener('mouseup', () => {
                isMouseDown = false;
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isMouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                // Rotar c√°mara alrededor de la Tierra
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                
                const distance = camera.position.length();
                const newDistance = distance + e.deltaY * 0.1;
                
                camera.position.normalize().multiplyScalar(
                    Math.max(10, Math.min(200, newDistance))
                );
            });
        }
        
        function setupEventListeners() {
            // Control de tiempo
            document.getElementById('time-scale').addEventListener('input', (e) => {
                timeController.setTimeScale(parseFloat(e.target.value));
            });
            
            document.getElementById('pause-btn').addEventListener('click', () => {
                timeController.togglePause();
            });
            
            document.getElementById('step-btn').addEventListener('click', () => {
                const deltaTime = timeController.step();
                if (deltaTime > 0) {
                    updatePhysics(deltaTime);
                    updateVisuals();
                }
            });
            
            document.getElementById('reset-time-btn').addEventListener('click', () => {
                timeController.reset();
            });
            
            // Par√°metros del meteorito
            document.getElementById('meteorite-size').addEventListener('input', updateMeteoriteParams);
            document.getElementById('meteorite-density').addEventListener('input', updateMeteoriteParams);
            document.getElementById('meteorite-velocity').addEventListener('input', updateMeteoriteParams);
            
            // Creaci√≥n de meteoritos
            document.getElementById('create-meteorite').addEventListener('click', createCustomMeteorite);
            document.getElementById('create-apophis').addEventListener('click', createApophis);
            document.getElementById('clear-meteorites').addEventListener('click', clearAllMeteorites);
            
            // Deflecci√≥n
            document.getElementById('kinetic-impact').addEventListener('click', () => {
                if (meteorites.length > 0) {
                    DeflectionSystem.kineticImpact(meteorites[meteorites.length - 1]);
                }
            });
            
            document.getElementById('nuclear-pulse').addEventListener('click', () => {
                if (meteorites.length > 0) {
                    DeflectionSystem.nuclearPulse(meteorites[meteorites.length - 1]);
                }
            });
            
            document.getElementById('gravity-tractor').addEventListener('click', () => {
                if (meteorites.length > 0) {
                    DeflectionSystem.gravityTractor(meteorites[meteorites.length - 1]);
                }
            });
            
            document.getElementById('ion-beam').addEventListener('click', () => {
                if (meteorites.length > 0) {
                    DeflectionSystem.ionBeam(meteorites[meteorites.length - 1]);
                }
            });
            
            // Visualizaci√≥n
            document.getElementById('toggle-trajectories').addEventListener('click', toggleTrajectories);
            document.getElementById('toggle-prediction').addEventListener('click', togglePrediction);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function updateMeteoriteParams() {
            const size = parseFloat(document.getElementById('meteorite-size').value);
            const density = parseFloat(document.getElementById('meteorite-density').value);
            const velocity = parseFloat(document.getElementById('meteorite-velocity').value);
            
            document.getElementById('size-display').textContent = `${size}m`;
            
            let densityType = 'Roca';
            if (density > 5000) densityType = 'Met√°lico';
            if (density < 2000) densityType = 'Hielo';
            document.getElementById('density-display').textContent = `${densityType} (${density})`;
            
            document.getElementById('velocity-display').textContent = `${velocity} km/s`;
            
            // Calcular masa y energ√≠a
            const volume = (4/3) * Math.PI * Math.pow(size/2, 3);
            const mass = volume * density;
            const kineticEnergy = 0.5 * mass * Math.pow(velocity * 1000, 2);
            
            document.getElementById('mass-display').textContent = `${(mass / 1e6).toFixed(2)} Mt`;
            document.getElementById('energy-display').textContent = 
                `${(kineticEnergy / 4.184e15).toFixed(2)} Mt TNT`;
        }
        
        function createCustomMeteorite() {
            const size = parseFloat(document.getElementById('meteorite-size').value);
            const density = parseFloat(document.getElementById('meteorite-density').value);
            const velocity = parseFloat(document.getElementById('meteorite-velocity').value);
            
            new Meteorite({
                size: size,
                density: density,
                velocity: [-velocity * 1000, 0, 0],
                position: [100, 0, 0]
            });
            
            showNotification('‚òÑÔ∏è Meteorito creado!', 2000);
        }
        
        function createApophis() {
            new Meteorite({
                size: 340,
                density: 2600,
                velocity: [-30000, 0, 0],
                position: [200, 0, 0]
            });
            
            showNotification('üî• ¬°Apophis simulado! Di√°metro: 340m', 3000);
        }
        
        function clearAllMeteorites() {
            meteorites.forEach(meteorite => meteorite.destroy());
            meteorites = [];
            trajectoryTrackers = [];
            
            showNotification('üí• Todos los meteoritos eliminados', 2000);
        }
        
        function toggleTrajectories() {
            trajectoryTrackers.forEach(tracker => {
                tracker.setVisibility(!tracker.visible);
            });
        }
        
        function togglePrediction() {
            trajectoryTrackers.forEach(tracker => {
                tracker.predictTrajectory();
            });
        }
        
        function updatePhysics(deltaTime) {
            if (deltaTime > 0) {
                world.step(deltaTime);
                
                // Aplicar gravedad personalizada
                meteorites.forEach(meteorite => {
                    if (meteorite.gravityTractorActive) {
                        const tractorForce = new CANNON.Vec3(0, 0.01, 0);
                        meteorite.body.applyForce(tractorForce, meteorite.body.position);
                    }
                });
            }
        }
        
        function updateVisuals() {
            meteorites.forEach(meteorite => {
                meteorite.update();
            });
            
            // Actualizar predicciones peri√≥dicamente
            if (Math.random() < 0.1) { // 10% de probabilidad cada frame
                trajectoryTrackers.forEach(tracker => {
                    tracker.predictTrajectory();
                });
            }
        }
        
        function animate(currentTime) {
            animationId = requestAnimationFrame(animate);
            
            const deltaTime = timeController.update((currentTime - lastTime) / 1000);
            lastTime = currentTime;
            
            updatePhysics(deltaTime);
            updateVisuals();
            
            renderer.render(scene, camera);
            
            // Update debug info
            document.getElementById('meteorite-count').textContent = `Meteoritos: ${meteorites.length}`;
        }
        
        function showNotification(message, duration = 3000) {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.style.display = 'block';
            
            setTimeout(() => {
                notification.style.display = 'none';
            }, duration);
        }
        
        function hideLoading() {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('debug-info').style.display = 'block';
        }
        
        // ==========================================
        // INICIALIZACI√ìN PRINCIPAL
        // ==========================================
        
        async function startApp() {
            try {
                updateLoadingStatus('üîç Verificando dependencias...');
                
                if (typeof CANNON === 'undefined') {
                    throw new Error('Cannon.js no est√° disponible');
                }
                
                await loadThreeJS();
                
                updateLoadingStatus('üåç Creando mundo...');
                initPhysics();
                initThreeJS();
                
                updateLoadingStatus('üéÆ Configurando controles...');
                timeController = new TimeController();
                setupEventListeners();
                updateMeteoriteParams();
                
                hideLoading();
                animate(0);
                
                showNotification('üöÄ ¬°Simulaci√≥n de deflecci√≥n lista!', 3000);
                console.log('üéâ Simulaci√≥n completamente inicializada');
                
            } catch (error) {
                console.error('‚ùå Error fatal:', error);
                updateLoadingStatus(`‚ùå Error: ${error.message}`);
            }
        }
        
        // Iniciar cuando est√© listo
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startApp);
        } else {
            startApp();
        }
        
        console.log(`
        üõ°Ô∏è SIMULACI√ìN DE DEFLECCI√ìN DE METEORITOS
        =========================================
        
        ‚ú® Caracter√≠sticas avanzadas:
        ‚Ä¢ Control temporal completo (pausa, velocidad, step)
        ‚Ä¢ Visualizaci√≥n de trayectorias en tiempo real
        ‚Ä¢ Predicci√≥n de trayectorias futuras
        ‚Ä¢ F√≠sica realista con Cannon.js
        ‚Ä¢ M√∫ltiples estrategias de deflecci√≥n
        ‚Ä¢ An√°lisis de impacto en tiempo real
        ‚Ä¢ Par√°metros configurables (tama√±o, densidad, velocidad)
        
        üõ°Ô∏è Estrategias de deflecci√≥n:
        ‚Ä¢ Impacto cin√©tico (DART-style)
        ‚Ä¢ Pulso nuclear
        ‚Ä¢ Tractor gravitacional
        ‚Ä¢ Haz de iones
        
        üéÆ Controles temporales:
        ‚Ä¢ Pausa/Resume
        ‚Ä¢ Control de velocidad (0x a 5x)
        ‚Ä¢ Step-by-step
        ‚Ä¢ Reset temporal
        
        üìà Visualizaci√≥n:
        ‚Ä¢ Trayectorias pasadas (verde)
        ‚Ä¢ Predicciones futuras (rojo)
        ‚Ä¢ An√°lisis de impacto en tiempo real
        
        üöÄ ¬°Lista para salvar la Tierra!
        `);
        
    </script>
</body>
</html>