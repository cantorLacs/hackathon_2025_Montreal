<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🌌 Visualizador de Trayectorias de Asteroides NASA</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            width: 80px;
            height: 80px;
            border: 8px solid rgba(74, 144, 226, 0.3);
            border-top: 8px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 30px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #controls-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(10, 14, 39, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 20px;
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: none;
        }
        
        #info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 14, 39, 0.95);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            max-height: 85vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            display: none;
        }
        
        #info-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        #info-panel::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #info-panel::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }
        
        h2 {
            color: #4a90e2;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #6cb4ee;
            margin: 15px 0 10px 0;
            font-size: 16px;
        }
        
        .control-group {
            margin: 15px 0;
            padding: 10px;
            background: rgba(74, 144, 226, 0.1);
            border-radius: 8px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            color: #a0c4e8;
            font-size: 14px;
            font-weight: 500;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #1a1f3a;
            outline: none;
            margin: 10px 0;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            background: rgba(74, 144, 226, 0.2);
            border: 1px solid #4a90e2;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            font-size: 13px;
        }
        
        input[type="file"]::file-selector-button {
            background: #4a90e2;
            color: #fff;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        button {
            background: linear-gradient(135deg, #4a90e2, #357abd);
            color: #fff;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            margin: 5px 3px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            background: linear-gradient(135deg, #357abd, #4a90e2);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 144, 226, 0.4);
        }
        
        button.active {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
        }
        
        button.danger {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
        }
        
        .info-card {
            background: rgba(74, 144, 226, 0.15);
            padding: 12px;
            border-radius: 8px;
            margin: 10px 0;
            border-left: 4px solid #4a90e2;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 14px;
        }
        
        .info-label {
            color: #a0c4e8;
            font-weight: 500;
        }
        
        .info-value {
            color: #fff;
            font-weight: 600;
        }
        
        .asteroid-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }
        
        .asteroid-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(74, 144, 226, 0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .asteroid-item:hover {
            background: rgba(74, 144, 226, 0.25);
            border-left-color: #4a90e2;
        }
        
        .asteroid-item.selected {
            background: rgba(74, 144, 226, 0.3);
            border-left-color: #2ecc71;
        }
        
        .asteroid-item.hazardous {
            border-left-color: #e74c3c;
        }
        
        .asteroid-name {
            font-weight: 600;
            color: #fff;
            font-size: 14px;
        }
        
        .asteroid-info {
            font-size: 12px;
            color: #a0c4e8;
            margin-top: 4px;
        }
        
        .time-display {
            text-align: center;
            padding: 15px;
            background: linear-gradient(135deg, rgba(74, 144, 226, 0.2), rgba(46, 204, 113, 0.2));
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .time-display .date {
            font-size: 18px;
            font-weight: 700;
            color: #4a90e2;
        }
        
        .time-display .speed {
            font-size: 14px;
            color: #a0c4e8;
            margin-top: 5px;
        }
        
        .legend {
            background: rgba(10, 14, 39, 0.8);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 13px;
        }
        
        .legend-color {
            width: 30px;
            height: 4px;
            border-radius: 2px;
            margin-right: 10px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 10px 0;
        }
        
        .stat-box {
            background: rgba(74, 144, 226, 0.1);
            padding: 10px;
            border-radius: 6px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #4a90e2;
        }
        
        .stat-label {
            font-size: 11px;
            color: #a0c4e8;
            margin-top: 5px;
        }
        
        #controls-panel::-webkit-scrollbar,
        .asteroid-list::-webkit-scrollbar {
            width: 8px;
        }
        
        #controls-panel::-webkit-scrollbar-track,
        .asteroid-list::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }
        
        #controls-panel::-webkit-scrollbar-thumb,
        .asteroid-list::-webkit-scrollbar-thumb {
            background: #4a90e2;
            border-radius: 4px;
        }
        
        .toggle-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
        }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 14, 39, 0.98);
            border: 2px solid #4a90e2;
            border-radius: 12px;
            padding: 30px 50px;
            z-index: 2000;
            display: none;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        }
        
        .notification h3 {
            margin: 0 0 15px 0;
            color: #4a90e2;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <h2>🌌 Cargando Visualizador de Trayectorias</h2>
        <p id="loading-status">Inicializando Three.js...</p>
    </div>

    <div id="canvas-container"></div>

    <div id="controls-panel">
        <h2>🎮 Panel de Control</h2>
        
        <!-- Carga de Datos -->
        <div class="control-group">
            <h3>📂 Cargar Datos NASA</h3>
            <input type="file" id="nasa-json-file" accept=".json">
            <div class="stats-grid" style="margin-top: 10px;">
                <div class="stat-box">
                    <div class="stat-value" id="total-asteroids">0</div>
                    <div class="stat-label">Asteroides</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="hazardous-count">0</div>
                    <div class="stat-label">Peligrosos</div>
                </div>
            </div>
        </div>

        <!-- Control de Tiempo -->
        <div class="control-group">
            <h3>⏰ Control de Tiempo</h3>
            <div class="time-display">
                <div class="date" id="current-date">--</div>
                <div class="speed">Velocidad: <span id="time-speed">0.1 días/frame</span></div>
            </div>
            
            <label>� Saltar a Fecha Específica:</label>
            <input type="date" id="date-picker" style="width: 100%; padding: 8px; background: rgba(74, 144, 226, 0.2); border: 1px solid #4a90e2; border-radius: 6px; color: #fff; font-size: 13px; margin-bottom: 10px;">
                        <button id="jump-to-date" style="width: 100%; margin: 0 0 10px 0;"> Ir a esta Fecha</button>
            
            <label> Control Manual de Tiempo</label>
            <div style="position: relative; width: 100%; height: 80px; background: rgba(74, 144, 226, 0.1); border-radius: 8px; margin-bottom: 15px; display: flex; align-items: center; justify-content: center;">
                <div style="position: absolute; top: 50%; left: 0; right: 0; height: 2px; background: rgba(74, 144, 226, 0.3);"></div>
                <div style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); font-size: 11px; color: #a0c4e8;"></div>
                <div style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); font-size: 11px; color: #a0c4e8;"></div>
                <input type="range" id="jog-control" min="-100" max="100" value="0" step="1" 
                    style="width: 90%; cursor: grab; -webkit-appearance: slider-horizontal;">
            </div>
            <div id="jog-status" style="text-align: center; font-size: 12px; color: #4a90e2; margin-top: -10px; margin-bottom: 10px; min-height: 18px;">
                Centro - Velocidad Normal
            </div>
            
            <label> Velocidad de Simulación</label>
            <input type="range" id="time-speed-slider" min="0" max="50" step="0.1" value="5">>
            
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 3px; margin-top: 8px;">
                <button id="speed-slow" style="padding: 6px; font-size: 11px;">🐌 1h</button>
                <button id="speed-normal" style="padding: 6px; font-size: 11px;">▶️ 6h</button>
                <button id="speed-fast" style="padding: 6px; font-size: 11px;">⚡ 1d</button>
                <button id="speed-vfast" style="padding: 6px; font-size: 11px;">🚀 7d</button>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-top: 10px;">
                <button id="play-pause-btn">▶️ Play</button>
                <button id="reset-time-btn">🔄 Reset</button>
            </div>
        </div>

        <!-- Selección de Asteroides -->
        <div class="control-group">
            <h3>☄️ Asteroides Cargados</h3>
            <div>
                <button id="show-all-btn" style="width: 100%;">👁️ Mostrar Todos</button>
                <button id="show-hazardous-btn" style="width: 100%; margin-top: 5px;">⚠️ Solo Peligrosos</button>
            </div>
            <div class="asteroid-list" id="asteroid-list">
                <p style="text-align: center; color: #a0c4e8; padding: 20px;">
                    Carga un archivo JSON de NASA para comenzar
                </p>
            </div>
        </div>

        <!-- Opciones de Visualización -->
        <div class="control-group">
            <h3>👁️ Visualización</h3>
            <div style="background: rgba(74, 144, 226, 0.15); padding: 10px; border-radius: 6px; margin-bottom: 10px;">
                <p style="margin: 0; font-size: 13px; color: #a0c4e8;">
                    ℹ️ Las órbitas se muestran completas (período orbital completo)
                </p>
            </div>
            <button id="toggle-orbits-btn">🔵 Órbitas</button>
            <button id="toggle-labels-btn">🏷️ Etiquetas</button>
            <button id="toggle-earth-btn" class="active">🌍 Tierra</button>
            <button id="toggle-grid-btn">📐 Cuadrícula</button>
        </div>

        <!-- Leyenda -->
        <div class="legend">
            <h3 style="margin-top: 0;">📊 Leyenda</h3>
            <div class="legend-item">
                <div class="legend-color" style="background: #4a90e2;"></div>
                <span>Órbitas normales</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>Asteroides peligrosos</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #2ecc71;"></div>
                <span>Aproximación cercana</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #f39c12;"></div>
                <span>Asteroide seleccionado</span>
            </div>
        </div>
    </div>

    <div id="info-panel">
        <h2>ℹ️ Información del Asteroide</h2>
        <div id="asteroid-details">
            <p style="text-align: center; color: #a0c4e8; padding: 20px;">
                Selecciona un asteroide para ver detalles
            </p>
        </div>
    </div>

    <div class="toggle-panel">
        <button id="toggle-controls">🎮 Controles</button>
        <button id="toggle-info">ℹ️ Info</button>
    </div>

    <div class="notification" id="notification">
        <h3 id="notification-title">Notificación</h3>
        <p id="notification-message"></p>
    </div>

    <!-- Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    
    <script type="module">
        // ==========================================
        // 🚀 SISTEMA INTEGRADO DE VISUALIZACIÓN
        // ==========================================

        console.log('🌌 Iniciando visualizador de trayectorias...');

        // Importar TrajectorySimulator (inline para evitar problemas de módulos)
        class TrajectorySimulator {
            constructor() {
                this.AU = 149597870.7;
                this.G = 6.674e-11;
                this.solarMass = 1.989e30;
                this.earthRadius = 6371;
                this.keplerTolerance = 1e-8;
                this.maxKeplerIterations = 20;
            }

            loadNASAData(nasaObject) {
                const orbitalData = nasaObject.orbital_data;
                
                return {
                    id: nasaObject.id,
                    name: nasaObject.name,
                    elements: {
                        a: parseFloat(orbitalData.semi_major_axis) * this.AU,
                        e: parseFloat(orbitalData.eccentricity),
                        i: this.degreesToRadians(parseFloat(orbitalData.inclination)),
                        Omega: this.degreesToRadians(parseFloat(orbitalData.ascending_node_longitude)),
                        omega: this.degreesToRadians(parseFloat(orbitalData.perihelion_argument)),
                        M0: this.degreesToRadians(parseFloat(orbitalData.mean_anomaly)),
                        n: this.degreesToRadians(parseFloat(orbitalData.mean_motion) / 86400),
                        epoch: parseFloat(orbitalData.epoch_osculation),
                        period: parseFloat(orbitalData.orbital_period) * 86400
                    },
                    closeApproaches: nasaObject.close_approach_data ? nasaObject.close_approach_data.map(approach => ({
                        date: new Date(approach.close_approach_date_full),
                        julianDate: this.dateToJulian(new Date(approach.close_approach_date_full)),
                        velocity: parseFloat(approach.relative_velocity.kilometers_per_second),
                        distance: parseFloat(approach.miss_distance.kilometers)
                    })) : [],
                    diameter: {
                        min: nasaObject.estimated_diameter.kilometers.estimated_diameter_min,
                        max: nasaObject.estimated_diameter.kilometers.estimated_diameter_max,
                        avg: (nasaObject.estimated_diameter.kilometers.estimated_diameter_min + 
                             nasaObject.estimated_diameter.kilometers.estimated_diameter_max) / 2
                    },
                    orbitClass: orbitalData.orbit_class.orbit_class_type,
                    isHazardous: nasaObject.is_potentially_hazardous_asteroid
                };
            }

            solveKeplerEquation(meanAnomaly, eccentricity) {
                let E = meanAnomaly;
                
                for (let i = 0; i < this.maxKeplerIterations; i++) {
                    const f = E - eccentricity * Math.sin(E) - meanAnomaly;
                    const df = 1 - eccentricity * Math.cos(E);
                    const deltaE = f / df;
                    E -= deltaE;
                    
                    if (Math.abs(deltaE) < this.keplerTolerance) break;
                }
                
                return E;
            }

            eccentricToTrueAnomaly(E, e) {
                return 2 * Math.atan2(
                    Math.sqrt(1 + e) * Math.sin(E / 2),
                    Math.sqrt(1 - e) * Math.cos(E / 2)
                );
            }

            orbitalPosition(trueAnomaly, semiMajorAxis, eccentricity) {
                const r = semiMajorAxis * (1 - eccentricity * eccentricity) / 
                         (1 + eccentricity * Math.cos(trueAnomaly));
                
                return {
                    x: r * Math.cos(trueAnomaly),
                    y: r * Math.sin(trueAnomaly),
                    z: 0,
                    r: r
                };
            }

            orbitalToHeliocentric(orbitalPos, elements) {
                const {i, Omega, omega} = elements;
                
                const cosOmega = Math.cos(Omega);
                const sinOmega = Math.sin(Omega);
                const cosi = Math.cos(i);
                const sini = Math.sin(i);
                const cosomega = Math.cos(omega);
                const sinomega = Math.sin(omega);
                
                const x = (cosOmega * cosomega - sinOmega * sinomega * cosi) * orbitalPos.x +
                         (-cosOmega * sinomega - sinOmega * cosomega * cosi) * orbitalPos.y;
                         
                const y = (sinOmega * cosomega + cosOmega * sinomega * cosi) * orbitalPos.x +
                         (-sinOmega * sinomega + cosOmega * cosomega * cosi) * orbitalPos.y;
                         
                const z = (sinomega * sini) * orbitalPos.x + (cosomega * sini) * orbitalPos.y;
                
                return {x, y, z, r: orbitalPos.r};
            }

            calculatePositionAtTime(asteroid, julianDate) {
                const elements = asteroid.elements;
                const deltaTime = (julianDate - elements.epoch) * 86400;
                const meanAnomaly = elements.M0 + elements.n * deltaTime;
                const eccentricAnomaly = this.solveKeplerEquation(meanAnomaly, elements.e);
                const trueAnomaly = this.eccentricToTrueAnomaly(eccentricAnomaly, elements.e);
                const orbitalPos = this.orbitalPosition(trueAnomaly, elements.a, elements.e);
                const heliocentricPos = this.orbitalToHeliocentric(orbitalPos, elements);
                const earthPos = this.getEarthPosition(julianDate);
                
                const geocentricPos = {
                    x: heliocentricPos.x - earthPos.x,
                    y: heliocentricPos.y - earthPos.y,
                    z: heliocentricPos.z - earthPos.z
                };
                
                return {
                    heliocentric: heliocentricPos,
                    geocentric: geocentricPos,
                    orbital: orbitalPos,
                    trueAnomaly: trueAnomaly,
                    julianDate: julianDate,
                    earthDistance: Math.sqrt(
                        geocentricPos.x**2 + geocentricPos.y**2 + geocentricPos.z**2
                    )
                };
            }

            generateTrajectory(asteroid, startDate, endDate, timeStep = 86400) {
                const trajectory = [];
                const startJD = this.dateToJulian(startDate);
                const endJD = this.dateToJulian(endDate);
                const stepJD = timeStep / 86400;
                
                for (let jd = startJD; jd <= endJD; jd += stepJD) {
                    const position = this.calculatePositionAtTime(asteroid, jd);
                    trajectory.push({
                        ...position,
                        date: this.julianToDate(jd)
                    });
                }
                
                return trajectory;
            }

            getEarthPosition(julianDate) {
                const daysSinceEpoch = julianDate - 2451545.0;
                const earthAngle = (daysSinceEpoch / 365.25) * 2 * Math.PI;
                
                return {
                    x: this.AU * Math.cos(earthAngle),
                    y: this.AU * Math.sin(earthAngle),
                    z: 0
                };
            }

            degreesToRadians(degrees) {
                return degrees * Math.PI / 180;
            }

            dateToJulian(date) {
                return (date.getTime() / 86400000) + 2440587.5;
            }

            julianToDate(julianDate) {
                return new Date((julianDate - 2440587.5) * 86400000);
            }
        }

        // ==========================================
        // 🎮 VISUALIZADOR THREE.JS
        // ==========================================

        class AsteroidVisualizer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.simulator = new TrajectorySimulator();
                this.asteroids = [];
                this.orbitLines = new Map();
                this.asteroidMeshes = new Map();
                this.currentTime = new Date();
                this.timeSpeed = 1.0;
                this.isPaused = true;
                this.showOrbits = true;
                this.selectedAsteroid = null;
                this.scale = 1 / 1000000; // Escala para visualización
                this.timeSpeed = 1/24; // Velocidad inicial: 1 hora por frame
                this.cameraFollowMode = false; // Seguimiento de cámara
                this.cameraOffset = new THREE.Vector3(50, 50, 50); // Offset de la cámara
                this.cameraTarget = new THREE.Vector3(0, 0, 0); // Punto al que mira la cámara
                this.jogValue = 0; // Valor del control jog (-100 a 100)
                this.isJogging = false; // Si el usuario está usando el jog
                this.jogReturnInterval = null; // Intervalo para retornar el jog al centro
            }

            async init() {
                this.initThreeJS();
                this.createSolarSystem();
                this.setupControls();
                this.setupEventListeners();
                this.updateDatePicker(); // Inicializar date picker
                this.animate();
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('controls-panel').style.display = 'block';
                document.getElementById('info-panel').style.display = 'block';
            }

            initThreeJS() {
                // Escena
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000511);

                // Cámara
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    10000
                );
                this.camera.position.set(300, 200, 300);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Luces
                const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
                this.scene.add(ambientLight);

                const sunLight = new THREE.PointLight(0xffffff, 2, 2000);
                sunLight.position.set(0, 0, 0);
                this.scene.add(sunLight);

                // Estrellas
                this.createStarField();

                // Resize handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            createStarField() {
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 5000;
                const positions = new Float32Array(starCount * 3);

                for (let i = 0; i < starCount * 3; i++) {
                    positions[i] = (Math.random() - 0.5) * 5000;
                }

                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const starMaterial = new THREE.PointsMaterial({
                    color: 0xffffff,
                    size: 2,
                    sizeAttenuation: false
                });

                const stars = new THREE.Points(starGeometry, starMaterial);
                this.scene.add(stars);
            }

            createSolarSystem() {
                // Sol
                const sunGeometry = new THREE.SphereGeometry(10, 32, 32);
                const sunMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffff00
                });
                const sun = new THREE.Mesh(sunGeometry, sunMaterial);
                this.scene.add(sun);

                // Tierra
                const earthGeometry = new THREE.SphereGeometry(5, 32, 32);
                const earthMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4a90e2,
                    emissive: 0x112244
                });
                this.earth = new THREE.Mesh(earthGeometry, earthMaterial);
                this.scene.add(this.earth);

                // Órbita de la Tierra
                this.createEarthOrbit();

                // Cuadrícula
                const gridHelper = new THREE.GridHelper(500, 50, 0x444444, 0x222222);
                gridHelper.visible = false;
                this.gridHelper = gridHelper;
                this.scene.add(gridHelper);
            }

            createEarthOrbit() {
                const points = [];
                const segments = 128;
                const radius = this.simulator.AU * this.scale;

                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * radius,
                        0,
                        Math.sin(angle) * radius
                    ));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0x4a90e2, 
                    transparent: true,
                    opacity: 0.3
                });
                const earthOrbit = new THREE.Line(geometry, material);
                this.scene.add(earthOrbit);
            }

            setupControls() {
                let isDragging = false;
                let previousMousePosition = { x: 0, y: 0 };

                this.renderer.domElement.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;

                    // Desactivar seguimiento cuando se mueve la cámara manualmente
                    if (this.cameraFollowMode) {
                        this.cameraFollowMode = false;
                        this.updateFollowButton();
                    }

                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;

                    // Calcular posición relativa al target actual
                    const relativePos = new THREE.Vector3().subVectors(this.camera.position, this.cameraTarget);
                    const spherical = new THREE.Spherical();
                    spherical.setFromVector3(relativePos);

                    spherical.theta -= deltaX * 0.01;
                    spherical.phi += deltaY * 0.01;
                    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                    relativePos.setFromSpherical(spherical);
                    this.camera.position.copy(this.cameraTarget).add(relativePos);
                    this.camera.lookAt(this.cameraTarget);

                    previousMousePosition = { x: e.clientX, y: e.clientY };
                });

                this.renderer.domElement.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    
                    // Desactivar seguimiento cuando se hace zoom manualmente
                    if (this.cameraFollowMode) {
                        this.cameraFollowMode = false;
                        this.updateFollowButton();
                    }

                    // Calcular dirección desde target a cámara
                    const direction = new THREE.Vector3().subVectors(this.camera.position, this.cameraTarget);
                    const distance = direction.length();
                    const newDistance = Math.max(20, Math.min(1000, distance + e.deltaY * 0.5));
                    
                    // Mantener la dirección, solo cambiar distancia
                    direction.normalize().multiplyScalar(newDistance);
                    this.camera.position.copy(this.cameraTarget).add(direction);
                    this.camera.lookAt(this.cameraTarget);
                });
            }

            setupEventListeners() {
                // Carga de archivo
                document.getElementById('nasa-json-file').addEventListener('change', (e) => {
                    this.loadNASAFile(e.target.files[0]);
                });

                // Control de tiempo
                document.getElementById('play-pause-btn').addEventListener('click', () => {
                    this.togglePlayPause();
                });

                document.getElementById('reset-time-btn').addEventListener('click', () => {
                    this.resetTime();
                });

                // Saltar a fecha específica
                document.getElementById('jump-to-date').addEventListener('click', () => {
                    const dateValue = document.getElementById('date-picker').value;
                    if (dateValue) {
                        this.jumpToDate(new Date(dateValue));
                    }
                });

                // Enter en el date picker
                document.getElementById('date-picker').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const dateValue = e.target.value;
                        if (dateValue) {
                            this.jumpToDate(new Date(dateValue));
                        }
                    }
                });

                // Control JOG para avanzar/retroceder tiempo manualmente
                const jogControl = document.getElementById('jog-control');
                const jogStatus = document.getElementById('jog-status');
                
                if (jogControl && jogStatus) {
                    jogControl.addEventListener('input', (e) => {
                        this.jogValue = parseInt(e.target.value);
                        this.isJogging = true;
                        
                        // Limpiar intervalo de retorno si existe
                        if (this.jogReturnInterval) {
                            clearInterval(this.jogReturnInterval);
                            this.jogReturnInterval = null;
                        }
                        
                        // Actualizar display
                        if (this.jogValue === 0) {
                            jogStatus.textContent = 'Centro - Velocidad Normal';
                            jogStatus.style.color = '#4a90e2';
                        } else if (this.jogValue < 0) {
                            const speed = Math.abs(this.jogValue);
                            jogStatus.textContent = `⏪ Retrocediendo ${speed}%`;
                            jogStatus.style.color = '#e74c3c';
                        } else {
                            jogStatus.textContent = `⏩ Avanzando ${this.jogValue}%`;
                            jogStatus.style.color = '#2ecc71';
                        }
                    });
                    
                    // Al soltar el jog, volver al centro gradualmente
                    jogControl.addEventListener('mouseup', () => {
                        this.startJogReturn();
                    });
                    
                    jogControl.addEventListener('touchend', () => {
                        this.startJogReturn();
                    });
                    
                    // También manejar cuando el mouse sale del control
                    jogControl.addEventListener('mouseleave', (e) => {
                        if (e.buttons === 1) { // Si todavía está presionado
                            this.startJogReturn();
                        }
                    });
                }

                document.getElementById('time-speed-slider').addEventListener('input', (e) => {
                    const sliderValue = parseFloat(e.target.value);
                    // Escala logarítmica para mejor control en valores bajos (dividido por 50 para mayor lentitud)
                    this.timeSpeed = sliderValue <= 0 ? 0 : Math.pow(sliderValue, 1.5) / 50;
                    
                    // Mostrar en formato legible
                    if (this.timeSpeed < 0.1) {
                        document.getElementById('time-speed').textContent = `${(this.timeSpeed * 24).toFixed(1)} horas/frame`;
                    } else if (this.timeSpeed < 1) {
                        document.getElementById('time-speed').textContent = `${this.timeSpeed.toFixed(2)} días/frame`;
                    } else {
                        document.getElementById('time-speed').textContent = `${this.timeSpeed.toFixed(1)} días/frame`;
                    }
                });

                // Botones de velocidad rápida
                document.getElementById('speed-slow').addEventListener('click', () => {
                    this.setSpeed(1/24); // 1 hora por frame
                });
                document.getElementById('speed-normal').addEventListener('click', () => {
                    this.setSpeed(6/24); // 6 horas por frame
                });
                document.getElementById('speed-fast').addEventListener('click', () => {
                    this.setSpeed(1); // 1 día por frame
                });
                document.getElementById('speed-vfast').addEventListener('click', () => {
                    this.setSpeed(7); // 7 días por frame
                });

                // Visualización
                document.getElementById('toggle-orbits-btn').addEventListener('click', () => {
                    this.toggleOrbits();
                });

                document.getElementById('toggle-grid-btn').addEventListener('click', () => {
                    this.gridHelper.visible = !this.gridHelper.visible;
                });

                document.getElementById('show-all-btn').addEventListener('click', () => {
                    this.showAllAsteroids();
                });

                document.getElementById('show-hazardous-btn').addEventListener('click', () => {
                    this.showHazardousOnly();
                });

                // Toggle panels
                document.getElementById('toggle-controls').addEventListener('click', () => {
                    const panel = document.getElementById('controls-panel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                });

                document.getElementById('toggle-info').addEventListener('click', () => {
                    const panel = document.getElementById('info-panel');
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                });
            }

            async loadNASAFile(file) {
                if (!file) return;

                try {
                    const text = await file.text();
                    const data = JSON.parse(text);

                    this.showNotification('Cargando...', 'Procesando datos de NASA...');

                    // Limpiar asteroides anteriores
                    this.clearAsteroids();

                    // Procesar asteroides
                    const neoList = data.near_earth_objects || [];
                    let loadedCount = 0;
                    let hazardousCount = 0;

                    for (const neo of neoList.slice(0, 50)) { // Limitar a 50 para rendimiento
                        try {
                            const asteroid = this.simulator.loadNASAData(neo);
                            this.asteroids.push(asteroid);
                            this.createAsteroidVisualization(asteroid);
                            
                            loadedCount++;
                            if (asteroid.isHazardous) hazardousCount++;
                        } catch (error) {
                            console.warn('Error procesando asteroide:', error);
                        }
                    }

                    // Actualizar UI
                    document.getElementById('total-asteroids').textContent = loadedCount;
                    document.getElementById('hazardous-count').textContent = hazardousCount;
                    this.updateAsteroidList();

                    this.showNotification('¡Éxito!', `${loadedCount} asteroides cargados`, 2000);

                } catch (error) {
                    console.error('Error cargando archivo:', error);
                    this.showNotification('Error', 'No se pudo cargar el archivo JSON', 3000);
                }
            }

            createAsteroidVisualization(asteroid) {
                // 🎯 Generar órbita completa basada en el período orbital
                const startDate = new Date();
                
                // Calcular período orbital en días
                const orbitalPeriodDays = asteroid.elements.period / 86400;
                
                // Generar la órbita completa (un período completo)
                const endDate = new Date(startDate.getTime() + orbitalPeriodDays * 24 * 60 * 60 * 1000);
                
                // Número de segmentos proporcional al período (más segmentos para órbitas largas)
                const segments = Math.min(Math.max(64, Math.floor(orbitalPeriodDays / 7)), 256);
                const timeStep = (orbitalPeriodDays * 86400) / segments;
                
                const trajectory = this.simulator.generateTrajectory(asteroid, startDate, endDate, timeStep);

                // Crear línea de órbita COMPLETA (cerrada)
                const points = trajectory.map(point => new THREE.Vector3(
                    point.heliocentric.x * this.scale,
                    point.heliocentric.z * this.scale,
                    point.heliocentric.y * this.scale
                ));

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const color = asteroid.isHazardous ? 0xe74c3c : 0x4a90e2;
                const material = new THREE.LineBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.6
                });

                const orbitLine = new THREE.Line(geometry, material);
                orbitLine.visible = this.showOrbits;
                this.scene.add(orbitLine);
                this.orbitLines.set(asteroid.id, orbitLine);

                // Crear mesh del asteroide
                const size = Math.max(0.5, asteroid.diameter.avg * 0.01);
                const asteroidGeometry = new THREE.SphereGeometry(size, 8, 8);
                const asteroidMaterial = new THREE.MeshPhongMaterial({ 
                    color: asteroid.isHazardous ? 0xff4444 : 0x888888,
                    emissive: asteroid.isHazardous ? 0x330000 : 0x111111
                });

                const asteroidMesh = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
                this.scene.add(asteroidMesh);
                this.asteroidMeshes.set(asteroid.id, {
                    mesh: asteroidMesh,
                    trajectory: trajectory,
                    orbitalPeriod: orbitalPeriodDays
                });
            }

            updateAsteroidList() {
                const listContainer = document.getElementById('asteroid-list');
                listContainer.innerHTML = '';

                this.asteroids.forEach(asteroid => {
                    const item = document.createElement('div');
                    item.className = 'asteroid-item' + (asteroid.isHazardous ? ' hazardous' : '');
                    item.innerHTML = `
                        <div class="asteroid-name">${asteroid.name}</div>
                        <div class="asteroid-info">
                            Ø ${asteroid.diameter.avg.toFixed(1)} km | ${asteroid.orbitClass}
                            ${asteroid.isHazardous ? ' ⚠️' : ''}
                        </div>
                    `;
                    
                    item.addEventListener('click', () => {
                        this.selectAsteroid(asteroid);
                    });
                    
                    listContainer.appendChild(item);
                });
            }

            selectAsteroid(asteroid) {
                this.selectedAsteroid = asteroid;
                this.cameraFollowMode = true; // Activar seguimiento automáticamente

                // Actualizar UI
                document.querySelectorAll('.asteroid-item').forEach(item => {
                    item.classList.remove('selected');
                });
                event.target.closest('.asteroid-item').classList.add('selected');

                // Mostrar detalles
                const detailsContainer = document.getElementById('asteroid-details');
                detailsContainer.innerHTML = `
                    <div class="info-card">
                        <h3 style="margin-top: 0;">${asteroid.name}</h3>
                        <button id="follow-camera-btn" style="width: 100%; padding: 10px; margin-bottom: 10px; font-size: 14px; cursor: pointer; border: none; border-radius: 6px; color: white; background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); transition: all 0.3s ease;">
                            🎥 Dejar de Seguir
                        </button>
                        <div class="info-row">
                            <span class="info-label">ID:</span>
                            <span class="info-value">${asteroid.id}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Diámetro:</span>
                            <span class="info-value">${asteroid.diameter.min.toFixed(2)} - ${asteroid.diameter.max.toFixed(2)} km</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Clase Orbital:</span>
                            <span class="info-value">${asteroid.orbitClass}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Peligroso:</span>
                            <span class="info-value">${asteroid.isHazardous ? '⚠️ SÍ' : '✅ NO'}</span>
                        </div>
                    </div>
                    
                    <h3>🛰️ Elementos Orbitales</h3>
                    <div class="info-card">
                        <div class="info-row">
                            <span class="info-label">Semi-eje mayor:</span>
                            <span class="info-value">${(asteroid.elements.a / this.simulator.AU).toFixed(3)} AU</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Excentricidad:</span>
                            <span class="info-value">${asteroid.elements.e.toFixed(4)}</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Inclinación:</span>
                            <span class="info-value">${(asteroid.elements.i * 180 / Math.PI).toFixed(2)}°</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Período Orbital:</span>
                            <span class="info-value">${(asteroid.elements.period / 86400).toFixed(1)} días (${(asteroid.elements.period / 86400 / 365.25).toFixed(2)} años)</span>
                        </div>
                        <div class="info-row">
                            <span class="info-label">Tipo de Órbita:</span>
                            <span class="info-value">${asteroid.elements.e < 0.1 ? '🔵 Casi circular' : asteroid.elements.e < 0.5 ? '🟡 Elíptica' : '🔴 Muy elíptica'}</span>
                        </div>
                    </div>

                    ${asteroid.closeApproaches.length > 0 ? `
                        <h3>📅 Próximas Aproximaciones</h3>
                        ${asteroid.closeApproaches.slice(0, 5).map((approach, index) => `
                            <div class="info-card" style="position: relative;">
                                <div class="info-row">
                                    <span class="info-label">Fecha:</span>
                                    <span class="info-value">${approach.date.toLocaleDateString('es-ES', {
                                        year: 'numeric',
                                        month: 'short',
                                        day: 'numeric'
                                    })}</span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Distancia:</span>
                                    <span class="info-value">${(approach.distance / 384400).toFixed(2)} DL 
                                        ${approach.distance < 384400 ? '⚠️' : ''}
                                    </span>
                                </div>
                                <div class="info-row">
                                    <span class="info-label">Velocidad:</span>
                                    <span class="info-value">${approach.velocity.toFixed(2)} km/s</span>
                                </div>
                                <button class="jump-to-approach" data-approach-index="${index}" 
                                    style="width: 100%; margin-top: 8px; padding: 8px; font-size: 12px;">
                                    🎯 Ver esta Aproximación
                                </button>
                            </div>
                        `).join('')}
                    ` : ''}
                `;

                // Añadir event listeners a los botones
                setTimeout(() => {
                    // Botón de seguimiento de cámara
                    const followBtn = document.getElementById('follow-camera-btn');
                    if (followBtn) {
                        followBtn.addEventListener('click', () => {
                            this.toggleCameraFollow();
                        });
                    }

                    // Botones de aproximación
                    document.querySelectorAll('.jump-to-approach').forEach(button => {
                        button.addEventListener('click', (e) => {
                            const index = parseInt(e.target.dataset.approachIndex);
                            const approach = asteroid.closeApproaches[index];
                            if (approach) {
                                // Saltar a 1 día antes de la aproximación para ver el acercamiento
                                const targetDate = new Date(approach.date.getTime() - 24 * 60 * 60 * 1000);
                                this.jumpToDate(targetDate);
                                // Pausar para observar
                                this.isPaused = true;
                                document.getElementById('play-pause-btn').textContent = '▶️ Play';
                                // Establecer velocidad muy lenta (1 hora por frame)
                                this.setSpeed(1/24);
                                // Activar seguimiento
                                this.cameraFollowMode = true;
                                this.updateFollowButton();
                            }
                        });
                    });
                }, 100);

                // Enfocar cámara
                const meshData = this.asteroidMeshes.get(asteroid.id);
                if (meshData) {
                    const pos = meshData.mesh.position;
                    const distance = 50;
                    
                    // Establecer el target de la cámara al asteroide
                    this.cameraTarget.copy(pos);
                    
                    this.camera.position.set(pos.x + distance, pos.y + distance, pos.z + distance);
                    this.camera.lookAt(pos);
                }
            }

            togglePlayPause() {
                this.isPaused = !this.isPaused;
                const btn = document.getElementById('play-pause-btn');
                btn.textContent = this.isPaused ? '▶️ Play' : '⏸️ Pausa';
            }

            setSpeed(speed) {
                this.timeSpeed = speed;
                
                // Calcular valor del slider para la escala logarítmica inversa
                // timeSpeed = sliderValue^1.5 / 50
                // sliderValue = (timeSpeed * 50)^(1/1.5)
                const sliderValue = Math.pow(speed * 50, 1 / 1.5);
                document.getElementById('time-speed-slider').value = sliderValue;
                
                // Actualizar display
                if (this.timeSpeed < 0.1) {
                    document.getElementById('time-speed').textContent = `${(this.timeSpeed * 24).toFixed(1)} horas/frame`;
                } else if (this.timeSpeed < 1) {
                    document.getElementById('time-speed').textContent = `${this.timeSpeed.toFixed(2)} días/frame`;
                } else {
                    document.getElementById('time-speed').textContent = `${this.timeSpeed.toFixed(1)} días/frame`;
                }
            }

            resetTime() {
                this.currentTime = new Date();
                this.updateTimeDisplay();
                this.updateDatePicker();
            }

            jumpToDate(date) {
                this.currentTime = new Date(date);
                this.updateTimeDisplay();
                this.updateDatePicker();
                this.showNotification('📅 Fecha cambiada', `Saltando a ${this.currentTime.toLocaleDateString('es-ES')}`, 2000);
            }

            updateDatePicker() {
                const datePicker = document.getElementById('date-picker');
                if (datePicker) {
                    const year = this.currentTime.getFullYear();
                    const month = String(this.currentTime.getMonth() + 1).padStart(2, '0');
                    const day = String(this.currentTime.getDate()).padStart(2, '0');
                    datePicker.value = `${year}-${month}-${day}`;
                }
            }

            startJogReturn() {
                const jogControl = document.getElementById('jog-control');
                const jogStatus = document.getElementById('jog-status');
                
                // Retornar al centro gradualmente
                this.jogReturnInterval = setInterval(() => {
                    const currentValue = parseInt(jogControl.value);
                    
                    if (currentValue === 0) {
                        clearInterval(this.jogReturnInterval);
                        this.jogReturnInterval = null;
                        this.isJogging = false;
                        this.jogValue = 0;
                        jogStatus.textContent = 'Centro - Velocidad Normal';
                        jogStatus.style.color = '#4a90e2';
                        return;
                    }
                    
                    // Mover hacia el centro
                    const step = Math.sign(currentValue) * Math.max(1, Math.abs(currentValue) / 10);
                    const newValue = currentValue - step;
                    
                    // Si pasamos del centro, ir directo a 0
                    if (Math.sign(newValue) !== Math.sign(currentValue)) {
                        jogControl.value = 0;
                        this.jogValue = 0;
                    } else {
                        jogControl.value = newValue;
                        this.jogValue = newValue;
                    }
                    
                    // Actualizar display
                    if (this.jogValue === 0) {
                        jogStatus.textContent = 'Centro - Velocidad Normal';
                        jogStatus.style.color = '#4a90e2';
                    } else if (this.jogValue < 0) {
                        jogStatus.textContent = `⏪ Retrocediendo ${Math.abs(this.jogValue)}%`;
                        jogStatus.style.color = '#e74c3c';
                    } else {
                        jogStatus.textContent = `⏩ Avanzando ${this.jogValue}%`;
                        jogStatus.style.color = '#2ecc71';
                    }
                }, 50);
            }

            toggleCameraFollow() {
                this.cameraFollowMode = !this.cameraFollowMode;
                this.updateFollowButton();
                
                if (this.cameraFollowMode && this.selectedAsteroid) {
                    this.showNotification('🎥 Seguimiento activado', `Siguiendo a ${this.selectedAsteroid.name}`, 2000);
                } else {
                    this.showNotification('🎥 Seguimiento desactivado', 'Cámara libre', 2000);
                }
            }

            updateFollowButton() {
                const btn = document.getElementById('follow-camera-btn');
                if (btn) {
                    btn.textContent = this.cameraFollowMode ? '🎥 Dejar de Seguir' : '🎥 Seguir Objeto';
                    btn.style.background = this.cameraFollowMode ? 
                        'linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)' : 
                        'linear-gradient(135deg, #4a90e2 0%, #357abd 100%)';
                }
            }

            toggleOrbits() {
                this.showOrbits = !this.showOrbits;
                this.orbitLines.forEach(line => {
                    line.visible = this.showOrbits;
                });
            }

            showAllAsteroids() {
                this.orbitLines.forEach((line, id) => {
                    line.visible = this.showOrbits;
                });
                this.asteroidMeshes.forEach(data => {
                    data.mesh.visible = true;
                });
            }

            showHazardousOnly() {
                this.asteroids.forEach(asteroid => {
                    const line = this.orbitLines.get(asteroid.id);
                    const meshData = this.asteroidMeshes.get(asteroid.id);
                    
                    if (line) line.visible = asteroid.isHazardous && this.showOrbits;
                    if (meshData) meshData.mesh.visible = asteroid.isHazardous;
                });
            }

            clearAsteroids() {
                this.orbitLines.forEach(line => this.scene.remove(line));
                this.asteroidMeshes.forEach(data => this.scene.remove(data.mesh));
                this.orbitLines.clear();
                this.asteroidMeshes.clear();
                this.asteroids = [];
            }

            updateTimeDisplay() {
                document.getElementById('current-date').textContent = 
                    this.currentTime.toLocaleDateString('es-ES', {
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
            }

            showNotification(title, message, duration = 0) {
                const notification = document.getElementById('notification');
                document.getElementById('notification-title').textContent = title;
                document.getElementById('notification-message').textContent = message;
                notification.style.display = 'block';

                if (duration > 0) {
                    setTimeout(() => {
                        notification.style.display = 'none';
                    }, duration);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Actualizar tiempo
                if (!this.isPaused) {
                    // Aplicar velocidad base
                    let effectiveSpeed = this.timeSpeed;
                    
                    // Si el jog está activo, modificar la velocidad
                    if (this.isJogging && this.jogValue !== 0) {
                        // Jog modifica la velocidad: -100% a +100%
                        // Multiplicador: -2x a +2x de la velocidad base
                        const jogMultiplier = this.jogValue / 50; // -2 a +2
                        effectiveSpeed = this.timeSpeed * jogMultiplier;
                    }
                    
                    this.currentTime = new Date(this.currentTime.getTime() + effectiveSpeed * 86400000);
                    this.updateTimeDisplay();

                    // Actualizar posiciones de asteroides
                    const julianDate = this.simulator.dateToJulian(this.currentTime);

                    this.asteroidMeshes.forEach((data, asteroidId) => {
                        const asteroid = this.asteroids.find(a => a.id === asteroidId);
                        if (asteroid) {
                            const position = this.simulator.calculatePositionAtTime(asteroid, julianDate);
                            data.mesh.position.set(
                                position.heliocentric.x * this.scale,
                                position.heliocentric.z * this.scale,
                                position.heliocentric.y * this.scale
                            );
                        }
                    });

                    // Actualizar posición de la Tierra
                    const earthPos = this.simulator.getEarthPosition(julianDate);
                    this.earth.position.set(
                        earthPos.x * this.scale,
                        0,
                        earthPos.y * this.scale
                    );
                }

                // Actualizar target del asteroide seleccionado (SIEMPRE)
                if (this.selectedAsteroid) {
                    const meshData = this.asteroidMeshes.get(this.selectedAsteroid.id);
                    if (meshData) {
                        const targetPos = meshData.mesh.position;
                        
                        // Actualizar el target de la cámara SIEMPRE (no solo en seguimiento)
                        this.cameraTarget.lerp(targetPos, 0.05);
                        
                        // Si seguimiento activo, también mover la cámara
                        if (this.cameraFollowMode) {
                            // Posición objetivo de la cámara (con offset)
                            const targetCameraPos = new THREE.Vector3(
                                targetPos.x + this.cameraOffset.x,
                                targetPos.y + this.cameraOffset.y,
                                targetPos.z + this.cameraOffset.z
                            );
                            
                            // Interpolación suave (lerp) para movimiento fluido
                            this.camera.position.lerp(targetCameraPos, 0.05);
                        }
                        
                        // Siempre mirar al target actualizado
                        this.camera.lookAt(this.cameraTarget);
                    }
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // ==========================================
        // 🚀 INICIALIZACIÓN
        // ==========================================

        const visualizer = new AsteroidVisualizer();
        visualizer.init();

        console.log('✅ Visualizador inicializado correctamente');
    </script>
</body>
</html>